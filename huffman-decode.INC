; decode for COMPRESSED_PLAYFIELDS.INC Data
;
; 1. decode huffman
; 2. decode rle
; 3. decode pair, if we used it by --usepairs parameter


 .local

@AUX = 212
@REG  =   @AUX+14
@HEAP_PTR = 254

?tree = @REG+2          ; 2
?huffpointer = @reg+4   ; 2

?treesize = @reg+6      ; 2
?HuffBitCtr = @reg+8    ; 1
?HuffShiftReg = @reg+9  ; 1

?treecount = @reg+10    ; 2
?treecount2 = @reg+12   ; 2
?tc = @reg+14           ; 2
?bytecount = @reg+16    ; 2
?write_buffer = @reg+18 ; 2
?treetemp = @reg+20     ; 2
?x = @reg+22            ; 1
?y = @reg+23            ; 1
?rle_buffer = @reg+24   ; 2
?rle_buffer_backup = @reg+2 ; 2


 jmp @huffman_decode

; liefert im Fehlerfall, falls der Datensatz leer ist eine 0 zurueck
?no_data
  ldy #0
  ldx #0
  rts

; Decode a data blob generated by xl-packer
; huffman_decode(number, buffer to decode)
@huffman_decode
@huffman_decode_ii
  ldy #3                ; 2. Parameter ist Buffer
  lda (@heap_ptr),y
  sta ?write_buffer
  sta ?write_buffer2
  iny
  lda (@heap_ptr),y
  sta ?write_buffer+1
  sta ?write_buffer2+1

  ldy #1                ; 1. Parameter ist Index in compressed_data
  lda (@heap_ptr),y     ; es sind max 128 Indices moeglich
;  and #$7f

  asl                   ; Auslesen von @compressed_data[1. Parameter]
  tax
  lda @compressed_data,x
  sta @reg
  inx
  lda @compressed_data,x
  sta @reg+1

; (@reg) zeigt auf so einen Block
; ?real_size0
;  .word 960 ; size in bytes in real
; ; rle encode-start: 02 03 02 03 02 03 02 03 02 03 02 03 02 03 02 03 02 03 02 03 02 03 02 03 02 03 02 03 02 03 02 03 02 03 02 03 02 03 02 03
; ?rle_size0
;  .word 875 ; size in bytes when rle encoded
; ?rle_x0
;  .byte 1
; ?rle_y0
;  .byte 7
;
; ?huffman_size0
;  .word 234 ; size in bytes when rle and huffman encoded
;
; ; huffman encode-start: 101110010111001011100101
; ?huffman0
;
; ?huffman_tree0


  ldy #0                ; Laenge der Entpackten Daten
  lda (@reg),y
  sta ?real_length
  iny
  lda (@reg),y
  sta ?real_length+1

  ora ?real_length      ; wir ueberpruefen gleich mal, ob nicht 0 anliegt
  beq ?no_data          ; --> es gibt keine Daten, raus!


  iny                   ; Laenge der RLE gepackten Daten
  lda (@reg),y
  sta ?rle_length
  sta ?bytecount
  iny
  lda (@reg),y
  sta ?rle_length+1
  sta ?bytecount+1      ; wir setzen den ByteCounter fuer Huffman Countdown


  iny                   ; X Value fuer RLE
  lda (@reg),y
  sta ?x

  iny                   ; Y Value fuer RLE
  lda (@reg),y
  sta ?y

  iny                   ; Laenge der Huffman-encodierten Daten,
  lda (@reg),y          ; dahinter liegt unser Tree zum Entpacken der Huffman-Daten
  sta ?huff_length
  iny
  lda (@reg),y
  sta ?huff_length+1


  clc                   ; decodet wird in den uebergebenen Write Buffer
  lda ?write_buffer     ; erst addieren wir die reale Laenge hinzu
  adc ?real_length
  tay
  lda ?write_buffer+1
  adc ?real_length+1
  tax

  sec                   ; dann subtrahieren wir die rle_length so sollten wir
  tya                   ; den wenigsten Speicher verbrauchen
  sbc ?rle_length       ; wir laufen beim entpacken dem rle_buffer pointer hinterher
  sta ?rle_buffer       ; ohne ihn zu ueberholen
  sta ?write_buffer
  txa
  sbc ?rle_length+1
  sta ?rle_buffer+1
  sta ?write_buffer+1

  clc                   ; wir muessen noch 8 bytes addieren
  lda @reg
  adc #8                ; word of real_length, word of rle, 2 bytes + word of huffman_count
  tay
  lda @reg+1
  adc #0
  tax

  sty ?huffpointer
  stx ?huffPointer+1

;  clc                   ; jetzt noch die Anzahl an Bytes im Huffman
;  tya
;  adc ?huff_length
;  sta ?tree             ; ?tree zeigt jetzt in den Tree zum Decodieren der Huffman Daten
;  txa
;  adc ?huff_length+1
;  sta ?tree+1

; Es gibt nur noch einen Huffman tree
  lda #<@huffman_tree
  sta ?tree
  lda #>@huffman_tree
  sta ?tree+1
  nop   ; TODO: huffman-decoder darf nicht laenger werden, der Code muss exakt passen!!!!!!
;
; OO                     OOO    OOO
; OO                    OO     OO
; OOOOOOOO  OO     OO OOOOOO OOOOOO OOOO OOO   OOOOOOOO OOOOOOOO
; OO     OO OO     OO   OO     OO   OO OOO OO OO     OO OO     OO
; OO     OO OO     OO   OO     OO   OO  O  OO OO     OO OO     OO
; OO     OO OO     OO   OO     OO   OO  O  OO OO     OO OO     OO
; OO     OO  OOOOOOOO   OO     OO   OO  O  OO  OOOOOOOO OO     OO
;

  jsr ?getTreeSize     ; Berechnen der Tree Laenge (2 Nullen am Ende)
  sty ?treesize
;  stx ?treesize+1

  ldy #0                ; huffshiftreg initialisieren, damit Read_bit_from_stream funktioniert
  lda (?huffpointer),y
  sta ?HuffShiftReg

  lda #$08              ; nur beim Ersten mal mit 8 initialisieren!
  sta ?HuffBitCtr

; Jetzt kommt die eigentliche Arbeit, das Entpacken der Huffman Daten, wir laufen hier so lange durch
; bis der bytecount 0 erreicht hat. Der wird beim setzen eines Wertes erhoeht.
;     treecount = treesize - 2;
  jsr ?getTreeSizeMinus2
  sty ?treecount
  stx ?treecount+1

;     while (/*(outcount < dataout.length) &&*/ (incount < bitsAsString.length())) {
?while_loop
;       char ch =bitsAsString.charAt(incount);
  jsr Read_bit_from_stream ; 1
;       if (ch == '0') {
  bcs ?else_ch_is_one

;         int tc = tree[treecount];
  ldy #0
  jsr ?tree_treecount
  sty ?tc
  stx ?tc+1

;         if (tc >= 0) {
  bit ?tc+1
  bmi ?else_tc_negativ

;           buffer.add((byte) tc);
  tya
  jsr ?setAkkuInBuffer

;           treecount = treesize - 2;
  jsr ?getTreeSizeMinus2
  sty ?treecount
  stx ?treecount+1
  jmp ?endif1
;         }
;         else {
?else_tc_negativ
;           treecount = (Math.abs(tc * 2) - 2);
  jsr ?get_math_abs_tc_mul_2_sub_2
  sty ?treecount
  stx ?treecount+1
  jmp ?endif1
;         }
;       }
;       else { // if (ch == '1') {
?else_ch_is_one
;         int tc = tree[treecount + 1];
  ldy #2
  jsr ?tree_treecount
  sty ?tc
  stx ?tc+1
;         if (tc >= 0) {
  bit ?tc+1
  bmi ?else_tc_negativ2

;           buffer.add((byte) tc);
  tya
  jsr ?setAkkuInBuffer

;           treecount = treesize - 2;
  jsr ?getTreeSizeMinus2
  sty ?treecount
  stx ?treecount+1
  jmp ?endif1
;         }
;         else {
?else_tc_negativ2
;           treecount = (Math.abs(tc * 2) - 2);
  jsr ?get_math_abs_tc_mul_2_sub_2
  sty ?treecount
  stx ?treecount+1
;         }
;       }
?endif1
;       incount++;
;  inc ?incount
;  bne ?no_high_incount
;  inc ?incount+1
;?no_high_incount

  lda ?bytecount
  ora ?bytecount+1
  bne ?while_loop

;
; OOOOOOO  OO       OOOOOOO
; OO    OO OO       OO
; OO    OO OO       OO
; OO    OO OO       OOOOO
; OOOOOO   OO       OO
; OO   OO  OO       OO
; OO    OO OOOOOOOO OOOOOOO
;

; call @waitline #120

; AB HIER RLE ENTPACKEN!
; wir laufen dem Buffer hinterher, der rle-buffer aus dem wir die Daten lesen
; liegt knapp vor uns, trotzdem sollten wir diesen nicht erreichen.

  lda ?write_buffer2
  sta ?write_buffer
  lda ?write_buffer2+1
  sta ?write_buffer+1

  lda ?real_length
  sta ?bytecount
  lda ?real_length+1
  sta ?bytecount+1

  lda #@compressed_extension
  beq ?no_pair_init
; .if .def @compressed_pairs
  jsr ?init_rle_if_decode_pairs
; .endif

?no_pair_init
  jsr ?decode_rle

  lda #@compressed_extension
  beq ?no_pair_decode
; .if .def @compressed_pairs
  jsr ?decode_pairs
; .endif
?no_pair_decode
; Ausstieg, sollte alles geklappt haben
  ldy #1
  ldx #0
  rts

?decode_rle
?rle_loop
  ldy #0
  lda (?rle_buffer),y
  cmp ?x
  beq ?rle_decode_with_x

  cmp ?y
  beq ?rle_decode_with_y

  jsr ?setAkkuInBuffer

?check_rle_end
;  winc ?rle_buffer
  INC ?rle_buffer   ; 5
  BNE ?W    ; 2+1
  INC ?rle_buffer+1 ; 5
?W

  lda ?bytecount
  ora ?bytecount+1
  bne ?rle_loop
  rts

?rle_decode_with_y
  iny
  lda (?rle_buffer),y
  tax                  ; count of 0 bytes

  lda #0
  jsr ?setRLEBytes

?rle_two_more_inc
;  winc ?rle_buffer     ; wir erhoehen um 1, springen aber zum naechsten WINC
  inc ?rle_buffer
  bne ?check_rle_end    ; wir kuerzen hier mal ab
  inc ?rle_buffer+1
  jmp ?check_rle_end


?rle_decode_with_x
  iny
  lda (?rle_buffer),y
  tax                  ; count of bytes
  iny
  lda (?rle_buffer),y  ; das zu setzende Byte
  jsr ?setRLEBytes

;  winc ?rle_buffer     ; wir springen in einer Kaskade zurueck
  inc ?rle_buffer
  bne ?rle_two_more_inc ; wir kuerzen hier mal ab
  inc ?rle_buffer+1
  jmp ?rle_two_more_inc

; setzt ein in X vorgegebene Masse an Bytes
?setRLEBytes
?setRLEBytes_loop
    jsr ?setAkkuInBuffer
    dex
    bne ?setRLEBytes_loop
    rts

; Schreibt genau ein Byte in den Buffer und incrementiert diesen dann
; IMPORTANT, MUST NOT DESTROY THE ACCU!
?setAkkuInBuffer
    ldy #0
    sta (?write_buffer),y

    inc ?write_buffer
    bne ?no_high_buffer
    inc ?write_buffer+1
?no_high_buffer
?decrement_bytecount
    ldy ?bytecount+0   ;Test if the LSB is zero
    BNE ?SKIP          ;If it isn't we can skip the next instruction
    DEC ?bytecount+1   ;Decrement the MSB when the LSB will underflow
?SKIP
    DEC ?bytecount+0   ;Decrement the LSB

    rts



?get_math_abs_tc_mul_2_sub_2
  asl ?tc
  rol ?tc+1

  ldy ?tc
  ldx ?tc+1
  bpl ?not_negativ

  sec
  lda #0
  sbc ?tc
  tay
  lda #0
  sbc ?tc+1
  tax
?not_negativ

  sec
  tya
  sbc #2
  tay ; sta ?treecount
  txa
  sbc #0
  tax ; sta ?treecount+1
  rts



; (x*256+y) = tree[treecount + Y*]  ; Y* muss 2x angegeben werden
?tree_treecount
  lda ?treecount     ; treecount * 2 fuer word access
  asl
  sta ?treecount2
  lda ?treecount+1
  rol
  sta ?treecount2+1

  clc                ; tree + (treecount*2)
  lda ?tree
  adc ?treecount2
  sta ?treeTemp
  lda ?tree+1
  adc ?treecount2+1
  sta ?treeTemp+1

  iny                ; tree [treecount] auslesen
  lda (?treeTemp),y
  tax
  dey
  lda (?treeTemp),y
  tay
  rts



; treecount := treesize - 2
?getTreeSizeMinus2
    sec
    lda ?treesize
    sbc #2
    tay ; sta ?treecount
    lda #0
    sbc #0
    tax ; sta ?treecount+1
    rts


; Berechnen der Tree groesse
; VORSICHT, WIR GEHEN VON 256 BYTES AUS, GROESSERE TREES BRAUCHEN HIER EINE ANPASSUNG!
?getTreeSize
;     int treecount = 0;
  lda ?tree
  sta ?treecount
  lda ?tree+1
  sta ?treecount+1

  lda #0
  sta ?treesize
;  sta ?treesize+1

  ldx #0

?treesize_loop
;     while (!((tree[treesize] == 0) && (tree[treesize + 1] == 0))) {
  ldy #0
  lda (?treecount),y
  iny
  ora (?treecount),y
  iny
  ora (?treecount),y
  iny
  ora (?treecount),y

  beq ?treesize_count_done  ; wenn 4 bytes (2 word) == 0 dann sind wir fertig
;  iny
;       treesize++;
  inx
;  dey
  clc
  lda ?treecount
  adc #2
  sta ?treecount
  lda ?treecount+1
  adc #0
  sta ?treecount+1

  jmp ?treesize_loop
;     }

?treesize_count_done
  txa
  tay
  ldx #0
  rts



Read_bit_from_stream:         ; Read a single bit from input stream and return it in C flag
        dec ?HuffBitCtr
        bpl ?not_next_byte

        lda #$07
        sta ?HuffBitCtr
        inc ?HuffPointer
        bne ?no_high
        inc ?HuffPointer+1
?no_high
        ldy #0
        lda (?HuffPointer),Y  ; Read next byte in shift register
        sta ?HuffShiftReg
?not_next_byte
        asl ?HuffShiftReg
        rts

?init_rle_if_decode_pairs
  lda ?real_length+1
  lsr
  tax                     ; sta ?rle_length+1
  lda ?real_length
  ror
  tay                     ; sta ?rle_length

  clc                     ; wenn pair genutzt wird,
  tya                     ; den write_buffer auf write_buffer + real_length / 2 setzen
  adc ?write_buffer2
  sta ?write_buffer
  sta ?rle_buffer_backup  ; zusaetzlich merken
  txa
  adc ?write_buffer2+1
  sta ?write_buffer+1
  sta ?rle_buffer_backup+1

  sty ?bytecount          ; bytecount ist jetzt real_length / 2
  stx ?bytecount+1
  rts

?decode_pairs
  ; AB HIER PAIR ENTPACKEN
  lda ?write_buffer2
  sta ?write_buffer
  lda ?write_buffer2+1
  sta ?write_buffer+1

  lda ?real_length
  sta ?bytecount
  lda ?real_length+1
  sta ?bytecount+1

?pair_loop
  ldy #0
  lda (?rle_buffer_backup),y
  asl
  tax
  lda @compressed_pairs,x
;  lda @compressed_blocks,x
  sta (?write_buffer),y
  iny
  lda @compressed_pairs+1,x
;  lda @compressed_blocks+1,x
  sta (?write_buffer),y

  clc
  lda ?write_buffer
  adc #2
  sta ?write_buffer
  lda ?write_buffer+1
  adc #0
  sta ?write_buffer+1

;  winc ?rle_buffer_backup
  INC ?rle_buffer_backup   ; 5
  BNE ?W2    ; 2+1
  INC ?rle_buffer_backup+1 ; 5
?W2

  sec
  lda ?bytecount
  sbc #2
  sta ?bytecount
  lda ?bytecount+1
  sbc #0
  sta ?bytecount+1

  ora ?bytecount
;  lda ?bytecount
;  ora ?bytecount+1
  bne ?pair_loop
  rts

?real_length
 .word 0
?rle_length
 .word 0
?write_buffer2
 .word 0

?huff_length
 .word 0

;; Decode one symbol from a cannonical huffman encoded bistream
;; (To decode multiple symbols this have to be called within a loop)
;; Note that some variables must be inintialized before decoding the 1st symbol
;
;Get_Huff_Value
;        lda #$00
;        sta nbits
;        sta code_l
;        sta code_m
;        sta code_h              ; Needed only if some codes are longer than 16-bit
;        sta match_code_l
;        sta match_code_m
;        sta match_code_h        ; Needed only if some codes are longer than 16-bit
;
;main_loop:
;        inc nbits
;
;        jsr Read_bit_from_stream        ;Read one bit and shift in the current code variable
;        rol code_l
;        rol code_m
;        rol code_h
;
;        asl match_code_l
;        rol match_code_m
;        rol match_code_h
;
;        ; Search if the read code correspond to something...
;        ldy #$00
;search_loop:
;        lda Huffman_length_tbl, Y          ; Search for a node that has the current length
;        cmp nbits
;        bne not_found
;
;found_length:
;        lda match_code_l
;        cmp code_l
;        bne code_wrong
;        lda match_code_m
;        cmp code_m
;        bne code_wrong
;        lda match_code_h
;        cmp code_h
;        bne code_wrong
;
;found:
;        tya                ; Value in Y
;        rts
;
;code_wrong:
;        inc match_code_l        ; If the code is not this one, match_code is incremented by '1' and continue searching
;        bne not_found
;        inc match_code_m
;        bne not_found
;        inc match_code_h
;
;not_found:
;        iny                    ; Next code
;        bne search_loop        ; Continue for searching for same length
;        beq main_loop          ; Searching for a longer length
;
;Read_bit_from_stream:         ; Read a single bit from input stream and return it in C flag
;        dec HuffBitCtr
;        bpl _not_next_byte
;
;        lda #$07
;        sta HuffBitCtr
;        inc HuffPointerL
;        bne +
;        inc HuffPointerH
;
;+       lda (HuffPointerL),Y  ; Read next byte in shift register
;        sta HuffShiftReg
;_not_next_byte
;        lsr HuffShiftReg
;        rts
;
;Read_bit_from_stream:          ; Read a single bit from input stream and return it in C flag
;        lsr HuffShiftReg
;        bne _not_next_byte
;
;        lda (HuffPointerL),Y   ; Read next byte in shift register
;        inc HuffPointerL
;        bne +
;        inc HuffPointerH
;+       sec
;        ror a
;        sta HuffShiftReg
;_not_next_byte
;        rts
;
; .INCLUDE "/home/develop/lla.atarixl.programming/pacman/COMPRESSED-PLAYFIELDS.INC"
